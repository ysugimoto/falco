<!DOCTYPE html>
<html>
<head>
  <title>Falco VCL Wasm Test</title>
  <style>
    body { font-family: system-ui; max-width: 900px; margin: 0 auto; padding: 1rem; }
    textarea, pre { font-family: monospace; }
    textarea { width: 100%; height: 150px; }
    pre { background: #f6f8fa; padding: 1rem; overflow: auto; color: #24292f; }
    .error { color: red; }
    /* Syntax highlighting */
    .tok-keyword { color: #d63384; font-weight: bold; }
    .tok-string { color: #22863a; }
    .tok-number { color: #0550ae; }
    .tok-boolean { color: #0550ae; font-weight: bold; }
    .tok-comment { color: #6a737d; font-style: italic; }
    .tok-variable { color: #e36209; }
    .tok-operator { color: #d73a49; }
    .tok-punctuation { color: #24292f; }
    .tok-control { color: #6f42c1; font-weight: bold; }
  </style>
</head>
<body>
  <h1>Falco VCL Wasm Test</h1>
  <p id="status" class="loading">Loading Wasm...</p>

  <h2>VCL Input</h2>
  <textarea id="vcl">backend my_backend {
  .host = "example.com";
}

sub vcl_recv {
  #FASTLY RECV
  if (req.http.Host ~ "example\.com") {
    set req.http.X-Custom = "hello";
  }
  return(lookup);
}</textarea>

  <h2>Actions</h2>
  <button onclick="doTokenize()">Tokenize</button>
  <button onclick="doParse()">Parse</button>
  <button onclick="doFormat()">Format</button>
  <button onclick="doLint()">Lint</button>

  <h2>Result</h2>
  <pre id="result">Click a button above to see results.</pre>

  <script src="wasm_exec.js"></script>
  <script>
    const go = new Go();

    WebAssembly.instantiateStreaming(fetch("falco.wasm"), go.importObject)
      .then(result => {
        go.run(result.instance);
        document.getElementById("status").textContent = "Wasm loaded! FalcoVCL is ready.";
        document.getElementById("status").className = "";
      })
      .catch(err => {
        document.getElementById("status").textContent = "Failed to load Wasm: " + err;
        document.getElementById("status").className = "error";
      });

    function getVCL() {
      return document.getElementById("vcl").value;
    }

    function showResult(obj) {
      document.getElementById("result").textContent = JSON.stringify(obj, null, 2);
    }

    function formatErrorWithContext(message, line, position) {
      const lines = getVCL().split('\n');
      const lineIdx = line - 1;
      if (lineIdx < 0 || lineIdx >= lines.length) {
        return message;
      }
      const sourceLine = lines[lineIdx];
      const pointer = ' '.repeat(Math.max(0, position - 1)) + '^';
      return `${message}\n\n  ${line} | ${sourceLine}\n    | ${pointer}`;
    }

    function showErrorsWithContext(errors) {
      const lines = getVCL().split('\n');
      let output = '';
      for (const err of errors) {
        const line = err.line || 0;
        const position = err.position || 1;
        const lineIdx = line - 1;
        const severity = (err.severity || 'error').toUpperCase();
        const rule = err.rule ? ` (${err.rule})` : '';
        output += `[${severity}] ${err.message}${rule}\n`;
        if (line > 0 && lineIdx < lines.length) {
          const sourceLine = lines[lineIdx];
          const lineNum = String(line).padStart(3, ' ');
          const pointer = ' '.repeat(Math.max(0, position - 1)) + '^';
          output += `  ${lineNum} | ${sourceLine}\n`;
          output += `      | ${pointer}\n`;
        }
        output += '\n';
      }
      document.getElementById("result").textContent = output.trim() || 'No errors found.';
    }

    function doTokenize() {
      if (typeof FalcoVCL === "undefined") {
        showResult({ error: "Wasm not loaded" });
        return;
      }
      const result = FalcoVCL.tokenize(getVCL());
      if (result.error) {
        document.getElementById("result").textContent = result.error;
        return;
      }
      // Convert line/position to absolute offset
      const vcl = getVCL();
      const lineOffsets = [0];
      for (let i = 0; i < vcl.length; i++) {
        if (vcl[i] === '\n') lineOffsets.push(i + 1);
      }
      function toOffset(line, pos) {
        return lineOffsets[line - 1] + pos - 1;
      }

      let html = '';
      let lastOffset = 0;
      for (const tok of result.tokens) {
        const tokOffset = toOffset(tok.line, tok.position);
        // Add any text between last token and this one
        if (tokOffset > lastOffset) {
          html += escapeHtml(vcl.slice(lastOffset, tokOffset));
        }
        // Render token
        let literal = tok.literal;
        if (tok.category === 'string') literal = '"' + literal + '"';
        html += `<span class="tok-${tok.category}">${escapeHtml(literal)}</span>`;
        lastOffset = tokOffset + literal.length;
      }
      // Add remaining text
      if (lastOffset < vcl.length) {
        html += escapeHtml(vcl.slice(lastOffset));
      }
      document.getElementById("result").innerHTML = html;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function doParse() {
      if (typeof FalcoVCL === "undefined") {
        showResult({ error: "Wasm not loaded" });
        return;
      }
      const result = FalcoVCL.parse(getVCL());
      if (result.error) {
        const match = result.error.match(/line[:\s]+(\d+).*?position[:\s]+(\d+)/i);
        if (match) {
          const line = parseInt(match[1], 10);
          const pos = parseInt(match[2], 10);
          document.getElementById("result").textContent = formatErrorWithContext(result.error, line, pos);
        } else {
          document.getElementById("result").textContent = result.error;
        }
      } else {
        showResult(result.ast);
      }
    }

    function doFormat() {
      if (typeof FalcoVCL === "undefined") {
        showResult({ error: "Wasm not loaded" });
        return;
      }
      const result = FalcoVCL.format(getVCL(), {
        indentWidth: 2,
        indentStyle: "space"
      });
      if (result.error) {
        // Try to parse line:position from error message
        const match = result.error.match(/line[:\s]+(\d+).*?position[:\s]+(\d+)/i);
        if (match) {
          const line = parseInt(match[1], 10);
          const pos = parseInt(match[2], 10);
          document.getElementById("result").textContent = formatErrorWithContext(result.error, line, pos);
        } else {
          showResult(result);
        }
      } else {
        document.getElementById("result").textContent = result.formatted;
      }
    }

    function doLint() {
      if (typeof FalcoVCL === "undefined") {
        showResult({ error: "Wasm not loaded" });
        return;
      }
      const result = FalcoVCL.lint(getVCL());
      if (result.error) {
        // Parse error - try to extract line/position
        const match = result.error.match(/line[:\s]+(\d+).*?position[:\s]+(\d+)/i);
        if (match) {
          const line = parseInt(match[1], 10);
          const pos = parseInt(match[2], 10);
          document.getElementById("result").textContent = formatErrorWithContext(result.error, line, pos);
        } else {
          document.getElementById("result").textContent = result.error;
        }
      } else {
        showErrorsWithContext(result.errors || []);
      }
    }
  </script>
</body>
</html>
