// Code generated by __generator__/interpreter.go at once

package builtin

import (
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/ysugimoto/falco/ast"
	"github.com/ysugimoto/falco/interpreter/context"
	"github.com/ysugimoto/falco/interpreter/value"
	"github.com/ysugimoto/falco/token"
)

// Fastly built-in function testing implementation of table.lookup_regex
// Arguments may be:
// - TABLE, STRING, STRING
// Reference: https://developer.fastly.com/reference/vcl/functions/table/table-lookup-regex/
func Test_Table_lookup_regex(t *testing.T) {
	table := map[string]*ast.TableDeclaration{
		"example": {
			Properties: []*ast.TableProperty{
				{
					Key: &ast.String{Value: "prod-server-1"},
					Value: &ast.String{
						Value: "production",
						Meta: &ast.Meta{
							Token: token.Token{Offset: 0},
						},
					},
				},
				{
					Key: &ast.String{Value: "prod-server-2"},
					Value: &ast.String{
						Value: "production",
						Meta: &ast.Meta{
							Token: token.Token{Offset: 0},
						},
					},
				},
				{
					Key: &ast.String{Value: "dev-server-1"},
					Value: &ast.String{
						Value: "development",
						Meta: &ast.Meta{
							Token: token.Token{Offset: 0},
						},
					},
				},
				{
					Key: &ast.String{Value: "test123"},
					Value: &ast.String{
						Value: "testing",
						Meta: &ast.Meta{
							Token: token.Token{Offset: 0},
						},
					},
				},
			},
		},
	}

	tests := []struct {
		name         string
		input        string
		pattern      string
		defaultValue string
		expect       string
		isError      bool
	}{
		{
			name:         "table does not exist",
			input:        "doesnotexist",
			pattern:      "prod.*",
			defaultValue: "fallback",
			expect:       "fallback",
			isError:      true,
		},
		{
			name:         "pattern matches first prod server",
			input:        "example",
			pattern:      "^prod-server-1$",
			defaultValue: "fallback",
			expect:       "production",
		},
		{
			name:         "pattern matches any prod server",
			input:        "example",
			pattern:      "prod-server-.*",
			defaultValue: "fallback",
			expect:       "production", // Should return first match
		},
		{
			name:         "pattern matches dev server",
			input:        "example",
			pattern:      "^dev-.*",
			defaultValue: "fallback",
			expect:       "development",
		},
		{
			name:         "pattern with character class",
			input:        "example",
			pattern:      "test[0-9]+",
			defaultValue: "fallback",
			expect:       "testing",
		},
		{
			name:         "pattern does not match",
			input:        "example",
			pattern:      "^staging-.*",
			defaultValue: "fallback",
			expect:       "fallback",
		},
		{
			name:         "invalid regex pattern",
			input:        "example",
			pattern:      "[invalid(",
			defaultValue: "fallback",
			expect:       "fallback",
			isError:      true,
		},
		{
			name:         "case sensitive match",
			input:        "example",
			pattern:      "^PROD-.*",
			defaultValue: "fallback",
			expect:       "fallback",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			args := []value.Value{
				&value.Ident{Value: tt.input},
				&value.String{Value: tt.pattern},
				&value.String{Value: tt.defaultValue},
			}
			ret, err := Table_lookup_regex(&context.Context{Tables: table}, args...)
			if err != nil {
				if !tt.isError {
					t.Errorf("Unexpected error: %s", err)
				}
				// Even with error, check the return value is as expected
			}
			if ret.Type() != value.StringType {
				t.Errorf("Unexpected return type, expect=STRING, got=%s", ret.Type())
			}
			v := value.Unwrap[*value.String](ret)
			if diff := cmp.Diff(tt.expect, v.Value); diff != "" {
				t.Errorf("Return value unmatch, diff=%s", diff)
			}
		})
	}
}
