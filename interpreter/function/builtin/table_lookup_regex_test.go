// Code generated by __generator__/interpreter.go at once

package builtin

import (
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/ysugimoto/falco/ast"
	"github.com/ysugimoto/falco/interpreter/context"
	"github.com/ysugimoto/falco/interpreter/value"
	"github.com/ysugimoto/falco/token"
)

// Fastly built-in function testing implementation of table.lookup_regex
// Arguments may be:
// - TABLE, STRING
// Reference: https://developer.fastly.com/reference/vcl/functions/table/table-lookup-regex/
func Test_Table_lookup_regex(t *testing.T) {
	table := map[string]*ast.TableDeclaration{
		"regex_patterns": {
			Properties: []*ast.TableProperty{
				{
					Key: &ast.String{Value: "/images"},
					Value: &ast.String{
						Value: "^(?:jpe?g|png)$",
						Meta: &ast.Meta{
							Token: token.Token{Offset: 0},
						},
					},
				},
				{
					Key: &ast.String{Value: "/articles"},
					Value: &ast.String{
						Value: "^md$",
						Meta: &ast.Meta{
							Token: token.Token{Offset: 0},
						},
					},
				},
			},
		},
	}

	tests := []struct {
		name             string
		tableName        string
		key              string
		expectPattern    string
		expectUnsatisfiable bool
		isError          bool
	}{
		{
			name:             "table does not exist",
			tableName:        "doesnotexist",
			key:              "/images",
			expectPattern:    "$unsatisfiable",
			expectUnsatisfiable: true,
			isError:          true,
		},
		{
			name:             "key found in table",
			tableName:        "regex_patterns",
			key:              "/images",
			expectPattern:    "^(?:jpe?g|png)$",
			expectUnsatisfiable: false,
		},
		{
			name:             "another key found in table",
			tableName:        "regex_patterns",
			key:              "/articles",
			expectPattern:    "^md$",
			expectUnsatisfiable: false,
		},
		{
			name:             "key not found returns unsatisfiable",
			tableName:        "regex_patterns",
			key:              "/videos",
			expectPattern:    "$unsatisfiable",
			expectUnsatisfiable: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			args := []value.Value{
				&value.Ident{Value: tt.tableName},
				&value.String{Value: tt.key},
			}
			ret, err := Table_lookup_regex(&context.Context{Tables: table}, args...)
			if err != nil {
				if !tt.isError {
					t.Errorf("Unexpected error: %s", err)
				}
			}
			if ret.Type() != value.RegexType {
				t.Errorf("Unexpected return type, expect=REGEX, got=%s", ret.Type())
			}
			v := value.Unwrap[*value.Regex](ret)
			if v.Unsatisfiable != tt.expectUnsatisfiable {
				t.Errorf("Unsatisfiable mismatch, expect=%v, got=%v", tt.expectUnsatisfiable, v.Unsatisfiable)
			}
			if diff := cmp.Diff(tt.expectPattern, v.Value); diff != "" {
				t.Errorf("Return value unmatch, diff=%s", diff)
			}
		})
	}
}
