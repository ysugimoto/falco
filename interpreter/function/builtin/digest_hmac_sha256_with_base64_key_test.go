// Code generated by __generator__/interpreter.go at once

package builtin

import (
	"encoding/base64"
	"encoding/hex"
	"testing"

	"github.com/ysugimoto/falco/interpreter/context"
	"github.com/ysugimoto/falco/interpreter/value"
)

// Fastly built-in function testing implementation of digest.hmac_sha256_with_base64_key
// Arguments may be:
// - STRING, STRING
// Reference:
func Test_Digest_hmac_sha256_with_base64_key(t *testing.T) {
	tests := []struct {
		keyHex  string
		message string
		expect  string
	}{
		// Test vectors from Varnish digest007.vtc
		{
			keyHex:  "5d694a15baddf0f503fec7e65ba434d3",
			message: "st=1678885238~exp=1679749238~acl=/*",
			expect:  "6a2915695030d8b83ae5c9c12d521a9f84d192398bb949e7b98f6efcc5bceb65",
		},
		{
			keyHex:  "ed90b9a043b6659d36acf36d5aeaec96",
			message: "st=1678885238~exp=1679749238~acl=/*",
			expect:  "5569ac4c81d200e56ce25ace987c8ea6194539a7c4eba3b32493d44081ced2f0",
		},
		{
			keyHex:  "ed90b9a043b6650036acf36d5aeaec96",
			message: "st=1678885238~exp=1679749238~acl=/*",
			expect:  "eddcfce5527bf76c5e2d2b777904f3545f2249b5f080cf0f41d8b980ade703c7",
		},
		{
			keyHex:  "5d694a00baddf0f503fec7e65ba434d3",
			message: "st=1678885238~exp=1679749238~acl=/*",
			expect:  "9309c89a4741fcac74592a7f3156d07402f168a2d829e25fb53798ad0c55788e",
		},
		{
			keyHex:  "00694a15baddf0f503fec7e65ba434d3",
			message: "st=1678885238~exp=1679749238~acl=/*",
			expect:  "7cef7427845f419d1c9aea350723909e994ebd7ea0dd70deac68f2cef9250064",
		},
	}

	for i, tt := range tests {
		// Convert hex key to bytes, then to base64
		keyBytes, err := hex.DecodeString(tt.keyHex)
		if err != nil {
			t.Fatalf("Test case %d: failed to decode hex key: %s", i, err)
		}
		keyBase64 := base64.StdEncoding.EncodeToString(keyBytes)

		ret, err := Digest_hmac_sha256_with_base64_key(
			&context.Context{},
			&value.String{Value: keyBase64},
			&value.String{Value: tt.message},
		)

		if err != nil {
			t.Errorf("Test case %d: unexpected error: %s", i, err)
			continue
		}
		if ret.Type() != value.StringType {
			t.Errorf("Test case %d: unexpected return type, expect=STRING, got=%s", i, ret.Type())
			continue
		}
		v := value.Unwrap[*value.String](ret)
		if v.Value != tt.expect {
			t.Errorf("Test case %d: return value unmatch, expect=%s, got=%s", i, tt.expect, v.Value)
		}
	}
}
