// Code generated by __generator__/interpreter.go at once

package builtin

import (
	"fmt"
	"unicode/utf8"

	"github.com/ysugimoto/falco/interpreter/context"
	"github.com/ysugimoto/falco/interpreter/function/errors"
	"github.com/ysugimoto/falco/interpreter/value"
)

const Json_escape_Name = "json.escape"

func Json_escape_Validate(args []value.Value) error {
	if len(args) != 1 {
		return errors.ArgumentNotEnough(Json_escape_Name, 1, args)
	}
	arg := args[0]
	switch arg.Type() {
	case value.AclType, value.IdentType:
		return errors.CannotConvertToString(Json_escape_Name, 1)
	case value.StringType, value.BooleanType:
		break
	default:
		if arg.IsLiteral() {
			return errors.New(Json_escape_Name, "%s type cannot be used as literal", arg.Type())
		}
	}
	return nil
}

var Json_escape_CharacterMap = map[rune][]rune{
	0x22: []rune("\\\""),
	0x5C: []rune("\\"),
	0x08: []rune("\\b"),
	0x09: []rune("\\t"),
	0x0A: []rune("\\n"),
	0x0C: []rune("\\f"),
	0x0D: []rune("\\r"),
}

// ref: http://www5d.biglobe.ne.jp/~noocyte/Programming/CharCode.html (JP)
func Json_escape_toUTF16SurrogatePair(r rune) []rune {
	r -= 0x10000
	upper := ((r >> 10) & 0x03FF) + 0xD800
	lower := (r & 0x03FF) + 0xDC00
	return []rune(fmt.Sprintf("\\u%04X\\u%04X", upper, lower))
}

// Fastly built-in function implementation of json.escape
// Arguments may be:
// - STRING
// Reference: https://developer.fastly.com/reference/vcl/functions/strings/json-escape/
func Json_escape(ctx *context.Context, args ...value.Value) (value.Value, error) {
	// Argument validations
	if err := Json_escape_Validate(args); err != nil {
		return value.Null, err
	}
	str := args[0].String()

	// Preparation: check provided is valid in UTF-8 sequence
	if !utf8.ValidString(str) {
		return &value.String{Value: ""}, nil
	}

	var escaped []rune
	for _, r := range []rune(str) {
		if v, ok := Json_escape_CharacterMap[r]; ok {
			escaped = append(escaped, v...)
			continue
		}
		if r < 0x1F || r == 0x7F || r == 0x2028 || r == 0x2029 {
			escaped = append(escaped, []rune(fmt.Sprintf("\\u%04x", r))...)
			continue
		}
		if r > 0xFFFF {
			escaped = append(escaped, Json_escape_toUTF16SurrogatePair(r)...)
			continue
		}
		escaped = append(escaped, r)
	}

	return &value.String{
		Value: string(escaped),
	}, nil
}
