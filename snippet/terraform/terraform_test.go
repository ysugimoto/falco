package terraform

import (
	"os"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestUnmarshallValidTfJson(t *testing.T) {
	fileName := "./data/terraform-valid.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	services, err := unmarshalTerraformPlannedInput(buf)
	if err != nil {
		t.Fatalf("Unexpected error %s unarshalling %s ", fileName, err)
	}

	if len(services) != 1 {
		t.Errorf("Length of services should be %d, got %d", 1, len(services))
	}

	if services[0].Acls[0].Name != "foo_acl" {
		t.Errorf("Acl name want %s, got %s", services[0].Acls[0].Name, "foo_acl")
	}

	if services[0].Backends[0].Name != "foo_backend" {
		t.Errorf("Backend name want %s, got %s", services[0].Backends[0].Name, "foo_backend")
	}

	if services[0].Dictionaries[0].Name != "foo_dictionary" {
		t.Errorf("Dictionary name want %s, got %s", services[0].Dictionaries[0].Name, "foo_dictionary")
	}
}

func TestUnmarshallInValidTfJson(t *testing.T) {
	fileName := "./data/terraform-invalid.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	_, err = unmarshalTerraformPlannedInput(buf)
	if err == nil {
		t.Fatalf("Expected error when unarshalling tf %s ", fileName)
	}
}

func TestUnmarshalWithAclEntryAndDictionaryItemsTsJson(t *testing.T) {
	fileName := "./data/terraform-entry-items.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	services, err := unmarshalTerraformPlannedInput(buf)
	if err != nil {
		t.Fatalf("Unexpected error when unarshalling tf %s ", fileName)
	}

	if len(services) != 1 {
		t.Errorf("Length of services should be %d, got %d", 1, len(services))
	}

	aclExpects := &Acl{
		Name: "test_acl",
		Entries: []*AclEntry{
			{
				Comment: "Entry-1",
				Ip:      "127.0.0.1",
				Negated: true,
				Subnet:  "24",
			},
			{
				Comment: "Entry-2",
				Ip:      "192.0.2.0",
				Negated: false,
				Subnet:  "32",
			},
		},
	}
	if diff := cmp.Diff(aclExpects, services[0].Acls[0]); diff != "" {
		t.Errorf("Unmarshalled ACL mismatch, diff=%s", diff)
	}

	dictExpects := &Dictionary{
		Name:      "example",
		WriteOnly: false,
		Items: []*DictionaryItem{
			{Key: "foo", Value: "bar"},
			{Key: "lorem", Value: "ipsum"},
		},
	}
	if diff := cmp.Diff(dictExpects, services[0].Dictionaries[0]); diff != "" {
		t.Errorf("Unmarshalled Dictionary mismatch, diff=%s", diff)
	}
}

func TestUnmarshalWithConditions(t *testing.T) {
	fileName := "./data/terraform-service-condition.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	services, err := unmarshalTerraformPlannedInput(buf)
	if err != nil {
		t.Fatalf("Unexpected error when unarshalling tf %s ", fileName)
	}

	if len(services) != 1 {
		t.Errorf("Length of services should be %d, got %d", 1, len(services))
	}

	conditionExpects := []*Condition{
		{
			Name:      "Generated by IP block list",
			Priority:  0,
			Statement: "client.ip ~ Generated_by_IP_block_list",
			Type:      "REQUEST",
		},
		{
			Name:      "Generated by synthetic response for 404 page",
			Priority:  0,
			Statement: "beresp.status == 404",
			Type:      "CACHE",
		},
	}
	if diff := cmp.Diff(conditionExpects, services[0].Conditions); diff != "" {
		t.Errorf("Unmarshalled conditions mismatch, diff=%s", diff)
	}
}

func TestUnmarshalWithHeaders(t *testing.T) {
	fileName := "./data/terraform-service-header.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	services, err := unmarshalTerraformPlannedInput(buf)
	if err != nil {
		t.Fatalf("Unexpected error when unarshalling tf %s ", fileName)
	}

	if len(services) != 1 {
		t.Errorf("Length of services should be %d, got %d", 1, len(services))
	}

	headerExpects := []*Header{
		{
			Name:             "test1",
			Action:           "set",
			Priority:         10,
			Type:             "request",
			Source:           `"foo"`,
			Destination:      "http.Header-Item",
			RequestCondition: "request_condition",
		},
		{
			Name:         "test2",
			Action:       "regex",
			Priority:     10,
			Type:         "response",
			Source:       "req.url",
			Destination:  "http.Header-Item",
			IgnoreIfSet:  true,
			Regex:        "/foo/([^/]+)/",
			Substitution: "$1",
		},
	}
	if diff := cmp.Diff(headerExpects, services[0].Headers); diff != "" {
		t.Errorf("Unmarshalled headers mismatch, diff=%s", diff)
	}
}

func TestUnmarshalWithResponseObjects(t *testing.T) {
	fileName := "./data/terraform-response-objects.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	services, err := unmarshalTerraformPlannedInput(buf)
	if err != nil {
		t.Fatalf("Unexpected error when unarshalling tf %s ", fileName)
	}

	if len(services) != 1 {
		t.Errorf("Length of services should be %d, got %d", 1, len(services))
	}

	roExpects := []*ResponseObject{
		{
			CacheCondition:   "",
			Content:          "",
			ContentType:      "text/html",
			Name:             "Generated by IP block list",
			RequestCondition: "Generated by IP block list",
			Response:         "Forbidden",
			Status:           403,
		},
		{
			CacheCondition:   "",
			Content:          "User-Agent: *\nDisallow: /",
			ContentType:      "text/plain",
			Name:             "Generated by synthetic response for robots.txt",
			RequestCondition: "Generated by synthetic response for robots.txt",
			Response:         "OK",
			Status:           200,
		},
	}
	if diff := cmp.Diff(roExpects, services[0].ResponseObjects); diff != "" {
		t.Errorf("Unmarshalled response objects mismatch, diff=%s", diff)
	}
}

func TestUnmarshalWithRequestSetting(t *testing.T) {
	fileName := "./data/terraform-request-settings.json"
	buf, err := os.ReadFile(fileName)

	if err != nil {
		t.Fatalf("Unexpected error %s reading file %s ", fileName, err)
	}

	services, err := unmarshalTerraformPlannedInput(buf)
	if err != nil {
		t.Fatalf("Unexpected error when unarshalling tf %s ", fileName)
	}

	if len(services) != 1 {
		t.Errorf("Length of services should be %d, got %d", 1, len(services))
	}

	rsExpects := []*RequestSetting{
		{
			ForceSSL: true,
		},
	}
	if diff := cmp.Diff(rsExpects, services[0].RequestSettings); diff != "" {
		t.Errorf("Unmarshalled request settings mismatch, diff=%s", diff)
	}
}
